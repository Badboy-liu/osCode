// 打开软件
cmd -> diskpart 
// 创建虚拟磁盘
create vdisk file=f:/osCode/dingst.vhd maximum=10 type=fixed


// 执行命令  http://www.chrysocome.net/downloads/dd-0.5.zip  
dd if=boot.bin of=E:/osCode/dingst.vhd bs=512 count=1

//用virtualBox 载入dingst.vhd

寄存器(register),双向的器件,一方面接收输入,也会产生输出 
ALU(算术逻辑单元) datasheet(数据手册),如何改变寄存器的状态,去操作计算机



内存:
指令和指令集: 指令放在内存中
设计cpu: cpu可以自动的进行运算
控制器: 分析一条一条的指令

8086: 有8个通用的寄存器  AX,BX,CX,DX,SI,DI,BP,SP.
还可以ax拆成两个8位的寄存器来用


AH,AL,BH,BL,CH,CL,DH,DL
IBM-PC 规定机器拉起在硬盘的7c00h处

代码段,数据段:在内存里面,在硬盘中拉起可执行文件,在内存中定义代码段和数据段 ds,和cs  

code segment 代码段  要执行的代码
data segment 数据段  运行后产生的数据
extra segment 附加寄存器  

分段机制 有多道程序 按需分配内存
想要执行什么程序,就把cs寄存器的值,去改变想要推进的程序
cs是16位的寄存器   
定义一个逻辑概念,首地址,每次从0开始执行

程序的加载可以通过一个管理程序进行调度
好处: 
	1.段加偏移可以灵活加载多道程序
	2.可以使程序定位更加广泛

post (power on slef testing) 操作系统的自检

把程序拉入内存,读非易失性的介质
将cpu指向程序的执行位置,cpu只能执行内存中的程序
第一启动的bios,需要了解bios,谁加载了bios,他被加载到哪里

8086寻址的方式是: 实模式,20位   ,寄存器是16位的,16位表示段手指+段偏移16 = 20位   16+4 = 20    2*2*2*2=16   16向左偏移4位+偏移地址16位

bios被硬件加载 640bp  以ibm的dos约定最少内存是32kb 0x8000 1kb(堆栈) 还有400kb 7c00h
第一个扇区在mbr在7c00h

最后一定是0xaa55


pc加电自检后一定后,80*25的文本模式
bios有自动寻找硬件功能,只要是0x55aa结尾,那么我们就能把他当做引导扇区使用,同时bios有内存布局的,不要轻易修改内存区域


ss 栈段寄存器
es 额外寄存器
IP 不可见寄存器
flags 标志寄存器
通用寄存器  AX,BX,CX,DX,SI,DI,BP,SP
AX:                 累加器
BX:用于存储起始位置  基地寄存器
CX:用作循环次数控制  计数器
ESI  复制指令的原地址   
EDI 复制指令的目的地址
DX: 数据段  存放数据 保存外设的端口地址
SP:栈指针寄存器
BP:栈用数据段访问方式的寄存器


立即数寻址:mov ax,0x18
内存寻址:mov ax[fs:0x123]
基址寻址: bx默认寄存器ds bp默认寄存器ss,bp(基于段的方式访问)和sp(基于栈的方式访问,指向栈顶)都有ss的有效地址,sp相当于游标,

读取和写入数据用到 data寄存器 error寄存器
device寄存器 8bit  硬盘状态寄存器 harddisk状态

1.先选择通道,往通道上的sector count寄存器,写入待操作的扇区
2.往该通道的3个LBA寄存器吸入扇区的起始地址
3.往device寄存器写入LBA的24-27位,设为LBA,设置dev,表明是从盘还是主盘
4.往commad寄存器写命令
5.检查status寄存器
6.读入数据

编译:e:/osCode/nasm-2.16.01/nasm.exe e:/osCode/loader.asm -o e:/osCode/loader.bin   
写入:./dd if=loader.bin of=dingst.vhd bs=512 count=1 seed=2 第二段

为什么从实模式转换到保护模式?
1.操作系统无法和用户程序做隔离
2.用户的逻辑地址访问的是实际地址
3.用户可以随便改变段基址


gdt :
1.全局描述符是一个段基址和偏移的结构体gdt   
2.放在内存中  
3.gdt里面有一个叫段描述符 
3.有个gdtr寄存器描述它

每一个应用程序可以独立的享有4g的空间
由mmu分配内存

平坦模型
从0-4g,为了使用好0-4g,我们必须规定所有的内存访问
1.定义程序的段
2.段的界限
3.段的权限
4.段的类型

1.段寄存器cs,ds不再是段基址,而是选择子
2.只有段选择子和段描述符,结合起来才能访问真正的物理地址
3.有gdt来管理这些段描述符
4.赋予了每一个程序在0-4g存放的权利
5.在保护模式下,每一个程序必须登记到全局描述符gdt global descriptor table
为整个软硬件服务的,加载程序由cpu注册段信息到全局描述符 每个描述符8个字节


gpt的加载过程
1.初始化全局描述表
2.将这个内存中的表,用lgdt加载
3.关闭a20地址线
3.打开cr0寄存器
4.进入保护模式




ldt 是省级别的注册总局
gdt 是国家级别的注册中心

两个结构一样

dpl: 段或者门的特权级，当代码段去访问对应的真实的地址,会判断权限

tss: task state segment(任务状态)

如果没有os,那么任务就等价于进程,任务实际是一段运行在处理器上的程序,用户程序和系统程序,所有的程序,在有os的情况下,写的是半成品,我们写的程序无法被加载,我们只负责用户态下面的,内核部分就是os提供的,任务是在cpu上推进,任务有权限的转化,处理器级别的特权变化,用os维护,有tss数据结构来维护,由硬件支持

tss维护栈的结构:tss是cpu硬件原生的系统级别的数据结构
gdt:在内存里面,用gdtr来访问的
tss:tr寄存器来访问
这种硬件级别的数据结构,有os(软件填写内容),有硬件使用
门:
	cpl:当前运行的权限
	dpl:某个东西权限的描述
	rpl:某种行为是否有权限

	当rpl和dpl权限一直才能运行:一致代码段

放生中断,操作系统需要把程序和cpu合成了一个任务,把较低的级别变成较高的级别,用户态变成内核态

